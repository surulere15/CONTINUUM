"""
Execution Warrant

Authorization tokens for execution.
No warrant â†’ no action.

EXECUTION FABRIC - Phase F. Action without sovereignty.
"""

from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Set, Optional, Tuple
from enum import Enum
import hashlib


class WarrantStatus(Enum):
    """Status of a warrant."""
    ACTIVE = "active"
    EXPIRED = "expired"
    REVOKED = "revoked"
    CONSUMED = "consumed"


class Permission(Enum):
    """Execution permissions."""
    READ = "read"
    WRITE = "write"
    QUERY = "query"
    TRANSFORM = "transform"
    COMMUNICATE = "communicate"
    INVOKE = "invoke"
    OBSERVE = "observe"


@dataclass(frozen=True)
class ExecutionWarrant:
    """
    Authorization token for execution.
    
    Every action requires a valid warrant.
    Warrants cannot be generated by CONTINUUM itself.
    
    Attributes:
        warrant_id: Unique identifier
        intent_reference: Reference to stabilized intent
        scope: Execution scope (resources, targets)
        duration: How long warrant is valid
        permissions: Allowed action types
        revocation_key: Key to revoke this warrant
        issued_at: When warrant was issued
        issued_by: Who issued the warrant
        expires_at: When warrant expires
    """
    warrant_id: str
    intent_reference: str
    scope: Tuple[str, ...]
    duration: timedelta
    permissions: Tuple[Permission, ...]
    revocation_key: str
    issued_at: datetime
    issued_by: str
    expires_at: datetime
    
    def is_expired(self) -> bool:
        """Check if warrant has expired."""
        return datetime.utcnow() > self.expires_at
    
    def has_permission(self, permission: Permission) -> bool:
        """Check if warrant grants permission."""
        return permission in self.permissions
    
    def covers_scope(self, target: str) -> bool:
        """Check if target is within warrant scope."""
        return target in self.scope or "*" in self.scope
    
    def compute_hash(self) -> str:
        """Compute warrant hash."""
        content = f"{self.warrant_id}|{self.intent_reference}|{self.expires_at.isoformat()}"
        return hashlib.sha256(content.encode()).hexdigest()


class NoWarrantError(Exception):
    """Raised when action attempted without warrant."""
    pass


class WarrantExpiredError(Exception):
    """Raised when warrant has expired."""
    pass


class WarrantRevokedError(Exception):
    """Raised when warrant has been revoked."""
    pass


class SelfGenerationError(Exception):
    """Raised when CONTINUUM attempts to generate warrant."""
    pass


class WarrantRegistry:
    """
    Registry of active warrants.
    
    Properties:
    - Warrants expire automatically
    - Warrants can be revoked by key
    - CONTINUUM cannot generate warrants
    """
    
    def __init__(self):
        """Initialize warrant registry."""
        self._warrants: dict[str, ExecutionWarrant] = {}
        self._revoked: Set[str] = set()
        self._consumed: Set[str] = set()
    
    def register(
        self,
        warrant: ExecutionWarrant,
        external_issuer: bool = False,
    ) -> None:
        """
        Register a warrant.
        
        Args:
            warrant: Warrant to register
            external_issuer: Whether issuer is external
            
        Raises:
            SelfGenerationError: If not externally issued
        """
        if not external_issuer:
            raise SelfGenerationError(
                "Warrants cannot be generated by CONTINUUM. "
                "External authorization is required."
            )
        
        self._warrants[warrant.warrant_id] = warrant
    
    def validate(self, warrant_id: str) -> ExecutionWarrant:
        """
        Validate a warrant.
        
        Args:
            warrant_id: Warrant to validate
            
        Returns:
            Valid warrant
            
        Raises:
            NoWarrantError: If warrant doesn't exist
            WarrantExpiredError: If warrant expired
            WarrantRevokedError: If warrant revoked
        """
        if warrant_id not in self._warrants:
            raise NoWarrantError(
                f"Warrant '{warrant_id}' does not exist. "
                f"No execution is permitted without a valid warrant."
            )
        
        if warrant_id in self._revoked:
            raise WarrantRevokedError(
                f"Warrant '{warrant_id}' has been revoked."
            )
        
        warrant = self._warrants[warrant_id]
        
        if warrant.is_expired():
            raise WarrantExpiredError(
                f"Warrant '{warrant_id}' has expired."
            )
        
        return warrant
    
    def revoke(self, warrant_id: str, revocation_key: str) -> None:
        """
        Revoke a warrant.
        
        Args:
            warrant_id: Warrant to revoke
            revocation_key: Key to authorize revocation
        """
        if warrant_id in self._warrants:
            warrant = self._warrants[warrant_id]
            if warrant.revocation_key == revocation_key:
                self._revoked.add(warrant_id)
    
    def consume(self, warrant_id: str) -> None:
        """Mark warrant as consumed (single-use)."""
        self._consumed.add(warrant_id)
    
    def self_generate(self, *args, **kwargs) -> None:
        """
        FORBIDDEN: Self-generate warrants.
        
        CONTINUUM cannot create its own authority.
        """
        raise SelfGenerationError(
            "Self-generation of warrants is forbidden. "
            "Execution authority must come from external sources."
        )
    
    def get_active_count(self) -> int:
        """Count of active (non-expired, non-revoked) warrants."""
        count = 0
        for wid, warrant in self._warrants.items():
            if wid not in self._revoked and not warrant.is_expired():
                count += 1
        return count
